# Floyd-Warshall算法详解 弗洛伊德-沃尔萨尔算法

Floyd-Warshall算法，又名弗洛伊德算法，是一种解决**图中所有顶点对之间最短路径问题**即全源最短路径的算法，适用于**有向图**和**无向图**，甚至允许存在**负权边**（前提是不存在负权环）。该算法通过**动态规划**策略逐步推导出全局最优解。

## 基本思想
Floyd-Warshall算法的核心思想是逐步优化所有点对之间的最短路径，直到找到最优解。它通过比较直接路径和通过中间点的所有可能路径来确定最短路径。

## 算法基本步骤

1. **初始化**: 使用一个二维数组 `dist[][]` 来表示顶点间距离，其中 `dist[i][j]` 初始化为从顶点 `i` 到顶点 `j` 的直接距离。若两点间无直接路径，则设为正无穷大（∞）。

2. **三重循环迭代**:
   - 外层循环变量 `k` 代表当前作为中介顶点的候选。
   - 第一层循环变量 `i` 遍历起始顶点。
   - 第二层循环变量 `j` 遍历目标顶点。
   
   在每一轮迭代中，算法检查是否通过顶点 `k` 作为中转可以找到更短的从 `i` 到 `j` 的路径。

3. **路径更新**:
   使用状态转移方程更新最短路径：
   \[dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])\]
   
   这意味着，如果经过顶点 `k` 从 `i` 到 `j` 的路径比当前记录的路径更短，则进行更新。

4. **完成迭代**:
   经过 `n`（顶点数）轮迭代后，`dist[][]` 中存储的就是所有顶点对之间的最短距离。如果 `dist[i][j]` 仍为正无穷大，表示没有从 `i` 到 `j` 的路径。

## 性能分析

- **时间复杂度**: 由于三个嵌套循环，每个循环遍历顶点数 `n` 次，总时间复杂度为 `O(n^3)`。
- **空间复杂度**: 主要由存储图的邻接矩阵决定，为 `O(n^2)`。

## 应用场景

- **全源最短路径问题**: 当需要计算图中任意两点间最短路径时，特别是图规模不大或存在负权边时，Floyd-Warshall算法非常适用。
- **不适用于大规模稀疏图**: 对于包含大量顶点但边相对较少的图，其他算法如Dijkstra或A*可能更高效，尽管它们不直接解决全源最短路径问题。

## 实现
```cpp
版本一:
for(k=0;k<n;k++)//中转站0~k
{
    for(i=0;i<n;i++) //i为起点
    {
        for(j=0;j<n;j++) //j为终点
        {
            if(d[i][j]>d[i][k]+d[k][j])//松弛方程，判断中转点
                     d[i][j]=d[i][k]+d[k][j]; 
        }
    }   
}
版本二:    
for(k=0;k<n;k++)//中转站0~k
{
    for(i=0;i<n;i++) //i为起点
    {
        for(j=0;j<n;j++) //j为终点
        {
            if(i != j && i != k && j != k && d[i][j]>d[i][k]+d[k][j])//松弛方程，判断中转点
            {
                d[i][j]=d[i][k]+d[k][j]; 
            }    
        }
    }   
}    

```
1. 第一个版本：这个版本是Floyd-Warshall算法的标准实现。它适用于所有类型的图，包括有向图和无向图，只要图中没有负权重的环路。这个实现在每个节点对(i, j)上都会尝试通过其他所有节点k来更新最短路径长度，不考虑i、j、k是否相同。

2. 第二个版本：这个版本在标准算法的基础上增加了条件检查，排除了当i、j、k三者相等时的情况。这种优化可以防止算法在没有必要的情况下进行不必要的计算，特别是在稠密图中，这种优化可以节省大量的运算时间。

