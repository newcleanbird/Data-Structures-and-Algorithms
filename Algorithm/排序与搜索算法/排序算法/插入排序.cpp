/*
插入排序：直接插入排序
1.思想: 输入：待排序数组    有序数组(为空)
        依次从待排序数组中取出元素，插入到有序数组中的正确位置，直到元素全部排序完成。
        or 将待排序的元素逐个与已排序的序列进行比较，找到合适的位置并插入;
        or 将位置P上的元素向左移动到正确位置上。前面的元素都是已经排序好的，因此插入到适合的位置即可。
2.实现：先保存当前待插入元素的值，然后向前移动，即前一个向后一个赋值(移动元素)，直到找适合的位置，插入。
3.时间复杂度：O(n^2) 
4.空间复杂度：O(1)
*/

// 大于 升序(小->大)  小于 降序(大->小)
# include<iostream>

using namespace std;
template<typename T>  
void InsertSort(T &A)   // A:待排序数组
{
    int N = sizeof(A) / sizeof(A[0]);
    cout << sizeof(A) << " " << sizeof(A[0]) << endl;
    int i, j;
    int key;
    for(i = 1; i < N; i++) // 从第2个元素开始插入，直到所有元素插入一遍。 每次插入就是向前寻找到正确的位置。
    {
        key = A[i]; // 保存当前插入的元素的值
        for(j = i; j > 0 && A[j - 1] > key; j--)   // 初始值：从比较元素向左开始(j=i)   判断：搜索范围是从i向左到0(j>0)，且比较值要比该位置的左边值要小(升序)(A[j-1] < key)，则继续搜素；否则即找到适合的位置  
        {                                          // 大于 升序(小->大)  小于 降序(大->小)
            A[j] = A [j - 1]; // 将左边值赋值到当前位置，即将左值右移       向左，一路前面的向后赋值，即把前一个元素移动到后一个元素。(也是比较的过程，发现前面的大，则把前面的往后移动)
        }
        A[j] = key; // 找到合适的位置，插入。 // 即在最终停止移动的位置赋上插入值。
    }
}

int main()
{
    int arr[] = {21,5,15,67,75,13,42}; // 测试用例
    InsertSort(arr); // 执行插入排序
    cout << "sizeof(arr)" << sizeof(arr) << endl;
    for(auto i : arr)
    {
        cout << i << endl;
    }
    system("pause");
}