// 快速排序

/*
选定一个基准，将其放在正确的位置上，左边比它小，后边比它大，称为一次快排，然后再分别对剩余的部分进行快排。

最坏情况：O(log 2 n) 
栈的深度O(n) 平均 O(log 2 n)
*/

/*
三种实现方法
    hoare版本(经典法，找到两个值进行交换)
        通过两个标志，分别从左往右找比基准值大的元素和从右向左找比基准值小的元素，然后交换两个元素，
        重复上述过程直到两个标志位相遇，最后再将基准值交换到相遇位置，然后再对左右子序列重复上述过程，直到整个序列完成排序。
    挖坑法(先设置基准值为坑，然后搜索过程中找到合适的就填坑，搜索位置设为坑，直到一轮结束)
        挖坑法大体思路与hoare法思路相同，其基本思想是：
        将基准值保存到标记位中，这样最右侧位置就形成了一个坑位，然后左侧标注位往右遍历找比基准值大的元素，
        找到后将该元素填入右侧坑位中，该位置就又形成了一个新的坑位，然后从右侧往左遍历找比基准值小的元素，
        将该元素填入到坑位中，重复上述过程直到左右标志位相遇，最后将基准值放入最后的坑位中，最对左右子序列重复上述过程直到整个序列排序完成。
    前后指针版本
        初始设置cur、prev两个标志指针，cur标志序列第一个元素，prev标志cur前一个位置，
        cur位置的元素若大于基准值，cur向前前进，若小于基准值，则先对prev进行加一，然后交换cur和prev标记位置的元素，
        这样就能保证cur与prev之间的元素都大于基准值，prev之前的元素都小于基准值，
        重复上述过程，直到cur超过序列最右侧位置，最后进行一次判断，若prev标记位置不是序列最后一个位置，则将基准值交换到prev交换位置，
        即完成左右子序列划分，再对左右子序列重复上述过程，直到整个序列完成排序。
*/

#include<bits/stdc++.h>

using namespace std;

// 极简版：Y总+优化后代码（经典版）
void quick_sort(int a[], int l, int r) {    // 待排序数组，左端点下标，右端点下标
    if (l >= r) return ;    // 如果左右端点重合或者左端点超过右端点，则结束(已经是最小的排序单元了)
    int x = a[l + r >> 1];  // x=[l+r>>1]：为数组最中间值，即选择最中间值作为基准数，也可以选择l、r或者任意一个值。
    int i = l, j = r;       // i从左端点开始向右寻找大于基准数的值，j从右端点开始，向左寻找小于基准数的值
    while (i <= j) {        // 左端点搜索不能超过右端点
        while(a[i] < x) i++;    // 如果i搜索的小于基准数,(没找到，自增)则继续寻找。直到找到一个较大值
        while(a[j] > x) j--;    // 如果j搜索的大于基准数,(没找到，自减)则继续寻找。直到找到一个较小值
        if (i <= j) swap(a[i++], a[j--]);    // 如果搜寻后依然满足i不超过j，则交换找到的a[i]和a[j]，并将i自增，j自减
    }                       // 一轮快排结束搜索结束
    quick_sort(a, l, j);    // 排左边的区间
    quick_sort(a, i, r);    // 排右边的区间
}
/*

代码解释：
l和r分别为对数组q[]进行排序的起始位置。
 
当l>=r时，函数直接返回，不执行后面的内容。
 
因为后面部分先执行i++,j--才进行其他操作，所以初始值设为l-1和r+1。
 
x的值可以取为q[l]、q[r]、q[(l+r)/2]、或者数组中的任意一值。此处取为q[l]能避免边界问题。
(例如此处如果取为q[r]，后面的代码需要进行相应的变动才是正确的，否则会存在边界问题。)
 
当i<j时，使得q[i]左边的数小于x，q[j]右边的数大于x。i和j都到达不满足大小判断条件的位置时，在满足i<j的条件下a[i]、a[j]互相交换位置。
 
上述步骤已经将数组的左、右区间调整好，接着分别递归左、右两段区间直到整个数组有序。
*/

int main()
{
    int a[] = {101, 15, 71, 37, 33, 66, 89, 7, 63, 17, 45, 78};
    quick_sort(a, 0, 11);
    for(auto i : a)
    {
        cout << i << endl;
    }
    system("pause");
}