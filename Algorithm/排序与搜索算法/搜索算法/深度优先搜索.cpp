/*
DFS:深度优先搜索
背景：DFS 英文全称为（Depth First Search），中文简称深度优先搜索算法，其过程为沿着每一个可能的路径向下进行搜索，直到不能再深入为止，并且每一个节点只能访问一次。
    深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。
    一般用"堆"数据结构来辅助实现DFS算法。
基本思想：
    沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
    当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。
    这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，
    整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。简单来说dfs可以看作是一个执着的人，
算法思想：
    dfs使用的数据结构是stack 栈，空间复杂度为o(n)；dfs中最重要的算法思想是回溯和剪枝。另外dfs不具有最短性。
    回溯是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，
    这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
    剪枝，就是减小搜索树规模、尽早排除搜索树中不必要的分支的一种手段。形象地看，就好像剪掉了搜索树的枝条，故称之为“剪枝”。

算法的搜索遍历图的步骤
（1）首先找到初始节点A
（2）依此从A未被访问的邻接点出发，对图进行深度优先遍历
（3）若有节点未被访问，则回溯到该节点，继续进行深度优先遍历
（4）直到所有与顶点A路径想通的节点都被访问过一次

*/

/*
经典题型：
    AcWing  824 排列数字
    给定一个整数 n，将数字 1∼n排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。

    输入格式
    共一行，包含一个整数 nn。

    输出格式
    按字典序输出所有排列方案，每个方案占一行。

    数据范围
    1≤n≤71≤n≤7

    输入样例：
    3

    输出样例：
    1 2 3
    1 3 2
    2 1 3
    2 3 1
    3 1 2
    3 2 1

*/

/*
DFS:
    1.创建结果存储变量，初始化当前结果
    2.设计递归函数  // (1)返回值，参数类型(需要用到的)
        函数执行过程：
            若到达结尾，则返回                          // 终止条件返回判断
            更新当前结果 (上一步已经判断，未到达结尾)  // 确定单层递归逻辑(更新)
            若到达末尾叶子节点，进行最优结果更新        // 判断要不要收集结果：更新最优结果
            分别对当前左右子树调用递归函数              // 只要往下一层有道路，不管有没有元素，依然进行搜索，递归终止判断部分会判断是否返回
    3.开始调用
*/
/*
模板:
function dfsTemplate(root) {
    //存储最终结果
    let res;
    //初始化当前结果
    let start;
    //构造递归函数dfs,通常参数为当前节点和当前结果
    let dfs = function (node, currentResult) {
        //终止条件返回判断
        if (node == null) {
            return;
        }
        //更新当前结果currentResult

        //若到达末尾叶子结点，进行最优结果更新
        if (node.left == null && node.right == null) {
            //update res
        }
        //左右子树递归
        dfs(node.left, currentResult);
        dfs(node.right, currentResult);
    }
    dfs(root, start);
    return res;
}



*/