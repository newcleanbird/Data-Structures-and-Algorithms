/*
算法
    本质:
        是系统创建一系列栈，每次重复调用该函数就会将该待处理的程序压入栈。
        {
            比如，我们最开始创建的程序是5*f(4) ，所以最先进栈，接着依次是4*f(3),3*f(2),2*f(1),f(1)=1 。
            注意：虽然系统创建了程序，但是还没有计算，因为没有到达终止条件，系统只是在不停的压入栈栈。
            最后到f(1)=1时候，无法继续压入栈。所以开始回溯，程序依次计算直到返回最开始进入的栈的程序的值，即为最终结果。
            总结：我们用最简单的例子还原了整个递归过程。所以，如果我们从细节处微观的来解决问题可谓是层层嵌套，十分复杂。 但是我们从中发现了规律，每一小步的过程都一样！
        }  
*/

/*
递归元素
1.终止条件：终止条件 统称为某一件事情的终止发生情况，即不可分割的最后一步。
    {
        eg：
        1.阶乘的第一个数一定是1。
        2.斐波纳契数列 前两个数 是1。
        3.叶子节点或者空节点。
        4.书的一页。
        5.教学楼的一个人。
    }
*抽象统一*:终止条件的特性是不可分割，不可构造。
    比如我们要算阶乘1x2x3x4，我们可以发现2！是1！x2  但是我们无法找到1！由谁构造出来。
    我们同样无法得知斐波那契数列前两个数是由谁相加的来。
    叶子节点如何再进行拆分？空节点如何再进行拆分？ 我们无从得知。
    我们要统计一本书有多少页，那么我们还能把书的一页撕开算成两页么？同样是不可分割的。
    我们要统计一个教学楼有多少人，我们可以先统计一个年级-->再统计一个班--->再统计一个小组--->最后统计人。不可能把人劈成两半来计算。
*这些就是基元*

2.递归关系：表示第n项和第n+1项之间的关系。

*抽象统一*：递归关系是表明前一项与后一项之间的联系，而且每项的递归关系都相同
    {
        eg：
        1.二叉树深度:父树的深度加一就是子树的的深度 这就是前一项与后一项的关系。
        2.斐波纳契数列：1，1，2，3，5     后一个是前两个数相加
        3. 杨辉三角  : 后一个是上面两个相加之合。
    }
*/

/*
3.递归模板
    第一步：根据题目判断返回类型。确定递归函数的参数和返回值：
    第二步：表达终止条件。确定终止条件:
    第三步：写最后一层递归条件。确定最后一层递归的逻辑：




*/





/*
递归三部曲：
    1.确定递归函数的参数和返回值： 
        确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
    2.确定终止条件
        写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，
        操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
    3.确定单层递归的逻辑
        确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
*/

/*
以下以前序遍历为例：
1. 确定递归函数的参数和返回值：
    因为要打印出前序遍历节点的数值，所以参数⾥需要传⼊vector在放节点的数值，
    除了这⼀点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，
    代码如下：
        void traversal(TreeNode* cur, vector<int>& vec)
2. 确定终⽌条件：
    在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，
    代码如下：
        if (cur == NULL) return;
3. 确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，
    代码如下：
        vec.push_back(cur->val); // 中
        traversal(cur->left, vec); // 左
        traversal(cur->right, vec); // 右
    
    单层递归的逻辑就是按照中左右的顺序来处理的，这样⼆叉树的前序遍历，基本就写完了，
        在看⼀下完整代码：
        前序遍历：
        class Solution {
        public:
        void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val); // 中
        traversal(cur->left, vec); // 左
        traversal(cur->right, vec); // 右
        }
        vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
        }
        };

        void 
*/

/*
递归实现指数型枚举:
    从1~n选择任意多个元素，输出所有的方案
1. 如果题目不要求输出方案必须升序
    填坑，从填1个坑到填n个坑。坑可以随便填，比如第1个坑选了2之后，第2个坑可以填1（非升序），也可以填3（升序）
*/    
#include <iostream>

using namespace std;

typedef long long ll;int n;

int a[20];
bool vis[20];// 一共tar个坑，当前枚举到第pos个坑

void dfs(int pos, int tar)  // 一共tar个坑，当前枚举到第pos个坑     // pos:开始位置(还没搜索) tar:本次搜索元素个数上限
{
    if (pos == tar + 1) // 递归终止条件(搜索元素(pos-1)==元素上限(tar)) 输出结果
    {
        for (int i = 1; i <= tar; i ++ ) 
        cout << a[i] << " ";
        cout << endl;
        return ;
    }
    // 选数填坑，选择的数范围是1～n
    for (int i = 1; i <= n; i ++) // 从集合1 ~n中选择进行填数
    {
        if (!vis[i]) 
        {
            vis[i] = true;
            a[pos] = i;
            dfs (pos + 1, tar);
            vis[i] = false;
        }
    }
}

int main() 
{
    cout << endl; // 不取
    cin >> n;
    for (int i = 1; i <= n; i ++ )  // 从0~n放n个数
        dfs(1, i);  // 第一个位置开始，填n个坑
    return 0;
}