# 动态规划

## 基本概念(DP)

动态规划:（Dynamic Programming，简称DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼等人在研究多阶段决策过程的优化问题时，提出并创立。动态规划是分治思想的延伸，通俗一点来说就是大事化小，小事化无的艺术。在将大问题化解为小问题的分治过程中，保存对这些小问题已经处理好的结果，并供后面处理更大规模的问题时直接使用这些结果。

理解算法：
动态规划(DP)通过循环做出每一步的最优解从而自底向上的得出对问题的整体最优解；这是它与分支算法的自顶向下求解和与贪心算法寻找局部最优解有本质的区别。

动态规划:
    动态规划过程：每一次决策依赖于当前的状态，即下一状态的产生取决于当前状态。
    一个决策序列就是在变化的状态中产生的，这种多阶段最优化问题的求解过程就是动态规则过程。
    动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，

基本思想原理:
    与分而治之原理类似，将待求解的问题划分成若干个子问题（阶段）求解，顺序求解各个子问题（阶段），前一子问题（阶段）为后一子问题（阶段）的求解提供有用的信息。
    通过各个子问题（阶段）的求解，依次递进，最终得到初始问题的解。一般情况下，能够通过动态规划求解的问题也可通过递归求解。
    动态规划求解的问题多数有重叠子问题的特点，为了减少重复计算，对每个子问题只求解一次，将不同子问题（阶段）的解保存在数组中。

与分而治之的区别：
    分而治之得到的若干子问题（阶段）一般彼此独立，各个子问题（阶段）之间没有顺序要求。
    而动态规划中各子问题（阶段）求解有顺序要求，具有重叠子问题（阶段），后一子问题（阶段）求解取决于前一子问题（阶段）的解。

与递归区别：
    与递归求解区别不大，都是划分成各个子问题（阶段），后一子问题（阶段）取决于前一子问题（阶段），
    但递归需要反复求解同一个子问题（阶段），相较于动态规划做了很多重复性工作。

### 动态规划算法的核心

理解一个算法就要理解一个算法的核心，动态规划算法的核心是下面的一张图片和一个小故事。

Those who cannot remember that past are condemned to repeat it. ——Dynamic Programming

```cpp
A * "1+1+1+1+1+1+1+1 =？" *

A : "上面等式的值是多少"
B : *计算* "8!"

A *在上面等式的左边写上 "1+" *
A : "此时等式的值为多少"
B : *quickly* "9!"
A : "你怎么这么快就知道答案了"
A : "只要在8的基础上加1就行了"
A : "所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"
```

### 动态规划算法的两种形式

上面已经知道动态规划算法的核心是记住已经求过的解，记住求解的方式有两种：①自顶向下的备忘录法 ②自底向上。

自顶向下：适合于实现较为复杂的递归关系，方便理解和调试，但可能会有额外的递归开销。
自底向上：通常更高效，避免了递归开销和栈溢出问题，但实现可能较为复杂。

#### 自顶向下的动态规划(自顶向下的备忘录法)

自顶向下（Top-Down）的方法，也称为记忆化搜索（Memoization），是通过递归的方式解决问题，并在解决过程中将计算结果存储起来，以避免重复计算。

步骤：

1. 定义递归函数：首先定义一个递归函数来解决问题，并且这个函数会将结果存储在一个数据结构中（通常是一个数组或哈希表）。
2. 基准情况：定义递归的基准情况，也就是最简单的情况，直接返回结果。
3. 递归关系：根据问题的递归关系将较复杂的情况分解成简单的子问题。
4. 存储结果：在递归调用之前，检查当前子问题的结果是否已经计算过（即是否在存储数据结构中）。如果已经计算过，则直接使用存储的结果；否则计算结果并存储。

- 优点：
  - 实现起来比较直观，容易理解。
  - 可以更容易地将问题分解成更小的子问题。
- 缺点：
  - 可能会有较高的递归调用开销，尤其是递归深度很大时。
  - 需要额外的空间来存储结果（即备忘录），这在空间复杂度上可能是一个问题。

#### 自底向上的动态规划

自底向上（Bottom-Up）的方法也称为迭代方法，它通过迭代的方式从最简单的子问题开始，逐步解决更复杂的问题，直到解决原始问题。

步骤：

1. 定义状态：定义一个状态数组来保存子问题的解。
2. 初始化状态：根据问题的基准情况初始化状态数组。
3. 迭代计算：通过迭代的方式，从最简单的子问题开始，利用之前已经计算过的结果来解决更复杂的子问题。
4. 返回结果：最终从状态数组中获取原问题的解。

- 优点：
  - 避免了递归的开销，因此在时间和空间上通常更高效。
  - 不会有递归调用的栈溢出问题。
- 缺点：
  - 实现上可能会比自顶向下方法复杂。
  - 需要预先定义好状态数组的大小，可能会浪费空间。

### 动态规划原理

重叠子问题和最优子结构

#### 最优子结构

用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。

#### 重叠子问题

在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。

## 适用解决问题

采用动态规划求解的问题一般具有如下性质：
    最优化原理：求解问题包含最优子结构，即，可由前一子问题（阶段）最优推导得出后一子问题（阶段）最优解，递进得到初始问题的最优解。
    无后效性：某状态以后的过程不会影响以前的状态，只与当前状态有关。
    有重叠子问题：子问题（阶段）之间不是独立的，一个子问题（阶段）的解在下一子问题（阶段）中被用到。（不是必需的条件，但是动态规划优于其他方法的基础）

### 动态规划三部曲

接下来为大家说明三步骤通解动态规划问题

动态规划解题模式
确定定义 —> 找初始值 —> 思考关系 =>写代码解

动态规划具备了以下三个特点：

把原来的问题分解成了几个相似的子问题。
所有的子问题都只需要解决一次。
储存子问题的解

动态规划的本质，是对问题状态的定义和状态转移方程的定义(状态以及状态之间的递推关系)。

动态规划问题一般从以下四个角度考虑：

确定dp数组（dp table）以及下标的含义(状态定义):定义的状态一定要形成递推关系。
确定递推公式(状态间的转移方程定义)
dp数组如何初始化(状态的初始化)
确定遍历顺序(返回结果)
举例推导dp数组

一句话概括：三特点四要素两本质
适用场景：最大值/最小值, 可不可行, 是不是，方案个数；

## 经典问题

### 青蛙跳台阶

问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
问题思想：
    1.找初始值：
        N   跳法                   总数
        1   1                       1
        2   11 2                    2
        3   111 12 21               3
        4   1111 112 121 211 22     4
    2.思考关系
        一般关系：跳到N台阶的情况，次数 = 跳到 n-1 台阶数 + n-2 台阶数  即：总跳法=最后跳一步的跳法数 + 最后跳两步的跳法数
        写出迭代方程：dp[n]=d[n-1]+d[n-2]
    3.写代码：
        本题本质是求斐波那契数列的变体解问题。

### 连续子数组的最大和

问题描述：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
    要求时间复杂度为O(n)。
    【示例】
    输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
    输出: 6
    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
1.确定定义
    本题问题是找出数组和的最大值，那就设最后要返回的最大值为 int max（值为最大和的子数组）
    动态规划是自底向上不断循环每一步的最优解来使得全局最优，全局最优解max已经有了
    再设出每一步的局部最优解 int dp（值为每次循环中求得的最大数组）
    {
        比如要求你三天吃饭用时最大的三餐时间之和max；那么 dp[n] 为你第n天里三顿中用时最长的一顿早/中/晚饭，
        max = dp[1] + dp[2] +dp[3]
    }
2.找初始值
    如果是找数组/字符规律那初始值就从最开始的0，1，2套入，然后发现其中特殊的的值
    但这里是求已知数组的最大值，而且已经定义好了max和dp，直接将0赋予作为初始值
    {
        int dp = nums[0];
        int max = nums[0];
    }
3.思考关系
    tip:有小伙伴可能想出想要 子数组和最大，其第一个和最后一个都一定是正数；毕竟开场和结尾可以选择的正数来最大化数组和，但要思考到 [-1] [-1,-2,-3] 这种示例，所以找首尾一定是正数的思维是在这里行不通的。
    数组和是由每一个单个的数字环环相扣连接累加而成（理解这句“废话“才能动态规划求最优解）
    重点：如果上一个最大和对自己是正影响那么就加上 这个最大和，如果上一个最大和对自己是负影响，那么该数不做任何改变。
    一个子数组m加上紧接的下一个数字n的值，m+n>n,那铁定把收编到数组里，但如果m+n<n; 那m数组还成了负担，不如重新让数字n替换为新的数组

### 礼物的最大价值

题目描述：
    一个m*n的棋盘，每一格都有一个礼物，每个礼物都有一定的价值(价值大于0)。
    你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格，直到到达格子右下角。
    给定一个棋盘，给定上面的价值，请你计算一共能拿到多少价值的礼物。

输入：
    [1,3,1]
    [1,5,1]
    [4,2,1]
    输出:12
    路径：1->3->5->2->1

1.确定定义
    注意传入的二维数组为 int[][] [] [] grid；
    新建一个n行m列的与输入同格式二维数组 int [] []dp
    但新建的二维数组dp里要装什么？动动你的小脑袋想想，

【动态规划通过循环做出每一步的最优解从而自底向上的得出对问题的整体最优解】（这句话在本文至少出现三遍…）,
    那当然显而易见的新建二维数组dp其中 每个元素 是当前循环中的想求的最优解
    看不懂上面这句话的笨蛋 在本文 Ctrl+F 搜索 “吃饭” ，背下例子并把【】的话背三十遍
    为了更清楚的解释我们建的dp数组要装什么玩意，这里举例（作者S1aine真的殚心竭虑地想给你说明白）

2.找初始值
    回忆一下刚才咱们在 “连续子数组的最大和” 里怎么定义初始值的？直接把初值第0个赋予了max和dp[i]
    这里的初值什么？ 第一反应是左上角的grid[0] [0] ，将它作为初始值赋予dp[0] [0]没有问题
    但是同时要结合题干考虑，题干里明确说了每次只能 “向右 或者 向下” 走，那就明显还需要边界的初始值来约束路径
    那边界初始值自然是dp中第0行和第0列了，求第0行和第0列两串初始值

3.思考关系
i,j表示行，列：
    当i = 0, j = 0时，为初始元素
    当i = 0,j != 0时，为第一列元素，只能从上面过来
    当i != 0, j = 0时，为第一行元素，只能从左边来
    当i != 0, j != 0时，可从左边或者上面到来

```cpp
    {
        dp[0][0] = gird[0][0];
        dp[0][j] = gird[0][j] + grid[0][j - 1];
        dp[i][0] = gird[i][j] + gird[i-1][0];
        dp[i][j] = gird[i][j] + max(dp[i-1][j], dp[i][j-1])
    }
```

### 字符串分割

给定一个字符串s，和一组单词，dict，判断s是否可以用空格分割成一个单词序列，使得单词序列中的所有单词都是dict中的单词(序列可以包含一个或者多个单词)。
如：s = "nowcode"
dice = ["now", "code"];
返回:true

1.状态定义：
    子状态：前1，2，3，…,n个字符能否根据词典中的词被成功分词
    F(i): 前i个字符能否根据词典中的词被成功分词

2.初始状态：
    F[0] = true;

3.状态递推：
    i状态时，判断依据：在i之前的某个j状态，F(j) = 1,且j+1 ~ i 也成功被分词
    F(i) = F(j) && (dice.find(s.substr(j,i - j) != dice.end());

### 三角矩阵的最小路径和

描述:给出一个三角形，计算从三角形顶部到底部的最小路径和，每一步都可以移动到下面一行相邻的数字，
例如，给出的三角形如下：
    [[20],[30,40],[60,50,70],[40,10,80,30]]
最小的从顶部到底部的路径和是20 + 30 + 50 + 10 = 110。
注意：
如果你能只用O（N）的额外的空间来完成这项工作的话，就可以得到附加分，其中N是三角形中的行总数。

分析：   20
       30 40
      60 50 70
     40 10 80 30
1.确定定义：
dp[][] 为该位置下的最优解。
`triangle[i][j]`

2.找初始值
`dp[0][0] = 20;` 初始值为第一个点的值。
每行的首和尾，都只能从上一行的首和尾获得。
`dp[i][0] = dp`

3.状态递推
dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + ;
