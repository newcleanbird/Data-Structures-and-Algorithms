/*
基本概念(DP)
动态规划:
    动态规划过程：每一次决策依赖于当前的状态，即下一状态的产生取决于当前状态。
    一个决策序列就是在变化的状态中产生的，这种多阶段最优化问题的求解过程就是动态规则过程。
    动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，
基本思想原理:
    与分而治之原理类似，将待求解的问题划分成若干个子问题（阶段）求解，顺序求解各个子问题（阶段），前一子问题（阶段）为后一子问题（阶段）的求解提供有用的信息。
    通过各个子问题（阶段）的求解，依次递进，最终得到初始问题的解。一般情况下，能够通过动态规划求解的问题也可通过递归求解。
    动态规划求解的问题多数有重叠子问题的特点，为了减少重复计算，对每个子问题只求解一次，将不同子问题（阶段）的解保存在数组中。
与分而治之的区别：
    分而治之得到的若干子问题（阶段）一般彼此独立，各个子问题（阶段）之间没有顺序要求。
    而动态规划中各子问题（阶段）求解有顺序要求，具有重叠子问题（阶段），后一子问题（阶段）求解取决于前一子问题（阶段）的解。
与递归区别：
    与递归求解区别不大，都是划分成各个子问题（阶段），后一子问题（阶段）取决于前一子问题（阶段），
    但递归需要反复求解同一个子问题（阶段），相较于动态规划做了很多重复性工作。

适用解决问题

采用动态规划求解的问题一般具有如下性质：
    最优化原理：求解问题包含最优子结构，即，可由前一子问题（阶段）最优推导得出后一子问题（阶段）最优解，递进得到初始问题的最优解。
    无后效性：某状态以后的过程不会影响以前的状态，只与当前状态有关。
    有重叠子问题：子问题（阶段）之间不是独立的，一个子问题（阶段）的解在下一子问题（阶段）中被用到。（不是必需的条件，但是动态规划优于其他方法的基础）



定义:（Dynamic Programming，简称DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼等人在研究多阶段决策过程的优化问题时，提出并创立。

理解认知
动态规划(DP)通过循环做出每一步的最优解从而自底向上的得出对问题的整体最优解；这是它与分支算法的自顶向下求解和与贪心算法寻找局部最优解有本质的区别。

接下来为大家说明三步骤通解动态规划问题

动态规划解题模式
确定定义 —> 找初始值 —> 思考关系 =>写代码解

*/

/*
DP（Dynamic Programming）定义：
动态规划是分治思想的延伸，通俗一点来说就是大事化小，小事化无的艺术。在将大问题化解为小问题的分治过程中，保存对这些小问题已经处理好的结果，并供后面处理更大规模的问题时直接使用这些结果。

动态规划具备了以下三个特点：

把原来的问题分解成了几个相似的子问题。
所有的子问题都只需要解决一次。
储存子问题的解
动态规划的本质，是对问题状态的定义和状态转移方程的定义(状态以及状态之间的递推关系)。

动态规划问题一般从以下四个角度考虑：

确定dp数组（dp table）以及下标的含义(状态定义):定义的状态一定要形成递推关系。
确定递推公式(状态间的转移方程定义)
dp数组如何初始化(状态的初始化)
确定遍历顺序(返回结果)
举例推导dp数组

一句话概括：三特点四要素两本质
适用场景：最大值/最小值, 可不可行, 是不是，方案个数；
*/


/*
1.青蛙跳台阶
问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
问题思想：
    1.找初始值：
        N   跳法                   总数
        1   1                       1
        2   11 2                    2
        3   111 12 21               3
        4   1111 112 121 211 22     4
    2.思考关系
        一般关系：跳到N台阶的情况，次数 = 跳到 n-1 台阶数 + n-2 台阶数  即：总跳法=最后跳一步的跳法数 + 最后跳两步的跳法数
        写出迭代方程：dp[n]=d[n-1]+d[n-2]
    3.写代码：
        本题本质是求斐波那契数列的变体解问题。
*/

/*
2.连续子数组的最大和
问题描述：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
    要求时间复杂度为O(n)。
    【示例】
    输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
    输出: 6
    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
1.确定定义
    本题问题是找出数组和的最大值，那就设最后要返回的最大值为 int max（值为最大和的子数组）
    动态规划是自底向上不断循环每一步的最优解来使得全局最优，全局最优解max已经有了
    再设出每一步的局部最优解 int dp（值为每次循环中求得的最大数组）
    {
        比如要求你三天吃饭用时最大的三餐时间之和max；那么 dp[n] 为你第n天里三顿中用时最长的一顿早/中/晚饭，
        max = dp[1] + dp[2] +dp[3]
    }
2.找初始值
    如果是找数组/字符规律那初始值就从最开始的0，1，2套入，然后发现其中特殊的的值
    但这里是求已知数组的最大值，而且已经定义好了max和dp，直接将0赋予作为初始值
    {
        int dp = nums[0];
        int max = nums[0];
    }
3.思考关系
    tip:有小伙伴可能想出想要 子数组和最大，其第一个和最后一个都一定是正数；毕竟开场和结尾可以选择的正数来最大化数组和，但要思考到 [-1] [-1,-2,-3] 这种示例，所以找首尾一定是正数的思维是在这里行不通的。
    数组和是由每一个单个的数字环环相扣连接累加而成（理解这句“废话“才能动态规划求最优解）
    重点：如果上一个最大和对自己是正影响那么就加上 这个最大和，如果上一个最大和对自己是负影响，那么该数不做任何改变。
    一个子数组m加上紧接的下一个数字n的值，m+n>n,那铁定把收编到数组里，但如果m+n<n; 那m数组还成了负担，不如重新让数字n替换为新的数组

*/

/*
礼物的最大价值:
题目描述：
    一个m*n的棋盘，每一格都有一个礼物，每个礼物都有一定的价值(价值大于0)。
    你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格，直到到达格子右下角。
    给定一个棋盘，给定上面的价值，请你计算一共能拿到多少价值的礼物。

    输入：
    [1,3,1]
    [1,5,1]
    [4,2,1]
    输出:12
    路径：1->3->5->2->1

1.确定定义
    注意传入的二维数组为 int[][] [] [] grid；
    新建一个n行m列的与输入同格式二维数组 int [] []dp
    但新建的二维数组dp里要装什么？动动你的小脑袋想想，

    【动态规划通过循环做出每一步的最优解从而自底向上的得出对问题的整体最优解】（这句话在本文至少出现三遍…）,
    那当然显而易见的新建二维数组dp其中 每个元素 是当前循环中的想求的最优解
    看不懂上面这句话的笨蛋 在本文 Ctrl+F 搜索 “吃饭” ，背下例子并把【】的话背三十遍
    为了更清楚的解释我们建的dp数组要装什么玩意，这里举例（作者S1aine真的殚心竭虑地想给你说明白）

2.找初始值
    回忆一下刚才咱们在 “连续子数组的最大和” 里怎么定义初始值的？直接把初值第0个赋予了max和dp[i]
    这里的初值什么？ 第一反应是左上角的grid[0] [0] ，将它作为初始值赋予dp[0] [0]没有问题
    但是同时要结合题干考虑，题干里明确说了每次只能 “向右 或者 向下” 走，那就明显还需要边界的初始值来约束路径
    那边界初始值自然是dp中第0行和第0列了，求第0行和第0列两串初始值

3.思考关系
i,j表示行，列：
    当i = 0, j = 0时，为初始元素
    当i = 0,j != 0时，为第一列元素，只能从上面过来
    当i != 0, j = 0时，为第一行元素，只能从左边来
    当i != 0, j != 0时，可从左边或者上面到来
    {
        dp[0][0] = gird[0][0];
        dp[0][j] = gird[0][j] + grid[0][j - 1];
        dp[i][0] = gird[i][j] + gird[i-1][0];
        dp[i][j] = gird[i][j] + max(dp[i-1][j], dp[i][j-1])
    }
*/

/*
字符串分割
    给定一个字符串s，和一组单词，dict，判断s是否可以用空格分割成一个单词序列，使得单词序列中的所有单词都是dict中的单词(序列可以包含一个或者多个单词)。
    如：s = "nowcode"
        dice = ["now", "code"];
    返回:true

1.状态定义：
    子状态：前1，2，3，…,n个字符能否根据词典中的词被成功分词
    F(i): 前i个字符能否根据词典中的词被成功分词

2.初始状态：
    F[0] = true;

3.状态递推：
    i状态时，判断依据：在i之前的某个j状态，F(j) = 1,且j+1 ~ i 也成功被分词
    F(i) = F(j) && (dice.find(s.substr(j,i - j) != dice.end());

*/

/*
三角矩阵的最小路径和
    描述:给出一个三角形，计算从三角形顶部到底部的最小路径和，每一步都可以移动到下面一行相邻的数字，
例如，给出的三角形如下：
    [[20],[30,40],[60,50,70],[40,10,80,30]]
最小的从顶部到底部的路径和是20 + 30 + 50 + 10 = 110。
注意：
如果你能只用O（N）的额外的空间来完成这项工作的话，就可以得到附加分，其中N是三角形中的行总数。

分析：   20
       30 40
      60 50 70
     40 10 80 30
1.确定定义：
dp[][] 为该位置下的最优解。
triangle[i][j]

2.找初始值
dp[0][0] = 20; 初始值为第一个点的值。
每行的首和尾，都只能从上一行的首和尾获得。
dp[i][0] = dp

3.状态递推
dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + ;
*/