/*
连续子数组的最大值：
问题描述：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
    要求时间复杂度为O(n)。
    【示例】
    输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
    输出: 6
    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
1.确定定义
    本题问题是找出数组和的最大值，那就设最后要返回的最大值为 int max（值为最大和的子数组）
    动态规划是自底向上不断循环每一步的最优解来使得全局最优，全局最优解max已经有了
    再设出每一步的局部最优解 int dp（值为每次循环中求得的最大数组）
    {
        比如要求你三天吃饭用时最大的三餐时间之和max；那么 dp[n] 为你第n天里三顿中用时最长的一顿早/中/晚饭，
        max = dp[1] + dp[2] +dp[3]
    }
2.找初始值
    如果是找数组/字符规律那初始值就从最开始的0，1，2套入，然后发现其中特殊的的值
    但这里是求已知数组的最大值，而且已经定义好了max和dp，直接将0赋予作为初始值
    {
        int dp = nums[0];
        int max = nums[0];
    }
3.思考关系
    tip:有小伙伴可能想出想要 子数组和最大，其第一个和最后一个都一定是正数；毕竟开场和结尾可以选择的正数来最大化数组和，但要思考到 [-1] [-1,-2,-3] 这种示例，所以找首尾一定是正数的思维是在这里行不通的。
    数组和是由每一个单个的数字环环相扣连接累加而成（理解这句“废话“才能动态规划求最优解）
    一个子数组m加上紧接的下一个数字n的值，m+n>n,那铁定把收编到数组里，但如果m+n<n; 那m数组还成了负担，不如重新让数字n替换为新的数组

    下举例中m和n都是随机设，主要是表示出这个道理
    {3，1，-2}中m为{3+1=4}时，n为-2；m+n>n，所以收编n后新数组m为{3,1,-2}
    {-6,2,-1}中m为{-6+2=-4}，n为-1；m+n<n，m数组值这么小反而成了累赘，所以令m=n，即m新设为{-1}
    将想清楚这种数组的最大构成关系后，就能模拟出关系表达式了
    dp = Math.max{ dp + num[i]，num[i]}

*/
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    int max_a = arr[0]; // 记录最大值
    int temp = arr[0]; // 当前目前最大值
    for(int i = 1; i < arr.size(); i++)
    {
        if(temp + arr[i] > arr[i]){
            temp += arr[i];
        }
        else{
            temp = arr[i];
        }
        max_a = max(temp, max_a);   
    }
    cout << max_a;
    system("pause");
}