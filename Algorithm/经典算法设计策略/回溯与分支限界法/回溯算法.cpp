/*
回溯算法
    回溯法也可以叫做回溯搜索法，它是⼀种搜索的⽅式.
    又称为“试探法”。解决问题时，每进行一步，都是抱着试试看的态度，如果发现当前选择并不是最好的，或者这么走下去肯定达不到目标，立刻做回退操作重新选择。
    这种走不通就回退再走的方法就是回溯算法。
核心:
    回溯=递归+局部暴力枚举
    回溯就是对递归进行纵横拓展，纵向就是递归，用来解决多层嵌套问题，因此有for有几层嵌套，递归就有几层，在这里就是K是多少就多少次递归。
    横向就是枚举每个点都有的情况。(集合所有元素)
核心概念：
    回溯函数：
        对应于递归函数
回溯搜索法：
    效率：纯暴力的搜索，因此效率不高，但有的问题纯暴力解决不了，因此只能使用回溯算法进行搜索。能有结果就不错了。
    解决问题：
        1.组合问题(强调没有顺序)：给一个集合：1 2 3 4,找出大小为2的组合：1 2；1 3；1 4；2 3；2 4；3 4
        2.切割问题：给一个字符串，问有多少种切割方式，加一些特定的条件：如何切割才能保证子串为回文子串等，问有几种切割方式
        3.子集问题：给一个集合，问子集有哪些：1 2 3 4 12 13 14 23 24 34 123 124 134 234 1234
        4.排列问题(强调有顺序)：
        {
            排列组合的区别：
                给定集合 1 2
                组合：无顺序，只看元素：12
                排列：有顺序，也看元素：12 21
        }
        5.棋盘问题：N皇后；解数独
如何理解回溯法:
    回溯法解决的问题都可以抽象为树形结构，所有回溯法的问题都可以抽象为树形结构！
    因为回溯法解决的都是在集合中递归查找⼦集，集合的⼤⼩就构成了树的宽度，递归的深度，都构成的树的深度。
    递归就要有终⽌条件，所以必然是⼀颗⾼度有限的树（N叉树）。
    做题第一步，先画树：
    
回溯法：
    核心思想：
        抽象为一个树形结构
        回溯就是一个递归的过程，递归有终止。
        数的宽度就是集合的大小。for循环进行遍历
        数的深度就是递归的深度
*/

/*
回溯三部曲
    1.回溯函数模板返回值以及参数
        void backtracking(参数)
    2.回溯函数终⽌条件
        核心：什么时候达到了终⽌条件，树中就可以看出，⼀般来说搜到叶⼦节点了，也就找到了满⾜条件的⼀条答案，把这个答案存放起来，并结束本层递归。
        回溯函数终⽌条件伪代码如下：
            if (终⽌条件) {
                存放结果;
                return;
            }
    3.回溯搜索的遍历过程
        在上⾯我们提到了，回溯法⼀般是在集合中递归搜索，集合的⼤⼩构成了树的宽度，递归的深度构成的树的深度。
        for循环-->横向遍历
        递归-->纵向遍历
        树状图表明：集合⼤⼩和孩⼦的数量是相等的！
        回溯函数遍历过程伪代码如下：
        for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
            处理节点;   // 将当前元素加入path
            backtracking(路径，选择列表); // 递归
            回溯，撤销处理结果  // 从path中pop()上一个加入的元素
        }


*/

/*
e.g.
回溯法
题目：集合n([1,n]个数)，长度为k的组合
1.确定递归函数的参数以及返回值
    需要用到，集合元素->n,path长度->k,开始搜索的位置startindex
2.确定递归的终止条件,收集解
    题目要求长度为k的组合，因此只要搜索到了长度为k的组合，那么即终止。 path.size() == k
    收集解：result.push_back(path);
3.确定单层搜索(递归)的逻辑
    从i=instartindex开始搜索，终止条件是将集合中的都搜索一遍(或者可个数小于需要的个数即推出)
    搜索：访问当前节点(i)时，将节点值加入到path中
    递归：继续搜索
*/

/*
回溯法的模板：
    递归函数：void backtracking() 参数很多
    递归函数的意义：就是在具体的一轮搜索中，排(搜索)具体的一位。
    void backtracking()
    {
        if(终止条件)
        {
            收集结果(一般在叶子节点，子集问题在每一个节点收集)  将结果放进结果集里；
            return 结果集
        }
        //单层搜索：
        for(集合元素集)
        {
            处理节点；
            递归函数；
            回溯操作；(撤销处理节点的情况)  // 组合问题：1 2; 1 3; 1 4  这个更改2/3/4(实则是删除2然后循环自动加入3的过程)就是一个回溯撤销的过程
        }
        return;
    }

*/
// 数的宽度就是集合的大小。for循环进行遍历
// 数的深度就是递归的深度
// 回溯其实就是某一层搜索时，利用回溯，依次对一个集合的元素进行搜索
/*
总结：
    0.模板问题；
        问题：
            问题描述
        分析：
            集合：每次搜索是同一个集合吗？每次搜索集合的元素个数，如何存储
            要求：问题的要求，每个结果内元素能不能重复(递归选择集合时如何处理),结果之间会不会异构重复(组合还是排列)
        搜索树：
            横向：搜索的集合大小          搜索开始的所有位置，一般依次从左向右  for循环，每次搜索开始位置
            纵向：一共有几层
            横向重复：异构重复
            纵向重复：元素重复--->搜索(使用)
        解决：
            横向重复：
            纵向重复：
        优化：
            剪枝：

    1.组合问题：第77题. 组合
        问题：
            给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
        分析：
            集合：同一个集合[1,n]
            要求：取k个数的组合
        搜索树：
            横向：[1,n] n个          不能从头开始，得从搜索处开始              从左向右取数，即每次取数，都可以从紧接着的下一个位置取数，集合元素随搜索位置开始位置右移而减少
            纵向：k层(取k个数)
            横向重复：不能异构(组合问题)  从不同的起点开始向右搜索，不会重复
            纵向重复：元素不能重复-->选择下一个搜索起点时，会+1，因此不会重复
        解决：
            横向重复：设置startindex，依次搜索集合
            纵向重复：每次搜索时，位置+1
            
        优化：
            剪枝
    2.组合总和：第216题.组合总和III
        问题：
            找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
        分析：
            集合：同一个集合[1,9]
            要求：k个数相加之和为n，一共能取k个，组合不能重复
        搜索树：
            横向：[1,9] 9个          不能从头开始，依次增加        从左向右取数，设置startindex，依次遍历
            纵向：k层(k个数)
            横向重复：不能异构
            纵向重复：元素不能重复
        解决：
            横向重复：设置startindex，依次搜索集合(起点不同)
            纵向重复：+1
    3.电话号码的字母组合：17.电话号码的字母组合
        问题：
            给定⼀个仅包含数字 2-9 的字符串，返回所有它能表⽰的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母
        特点：
            上下两层搜索没有关联，下次还能是新的集合，还能再搜索之前的位置。因此不需要设置startindex
            需要记录深度，设置index
        分析：
            集合：每次搜索集合不同，集合按照数字-->指定集合，因此选用哈希/二维string数组进行存储
            要求：给出所有的映射
        搜索树：
            横向：大小和当前集合长度有关
            纵向：字符串长度，有几个数字，搜索几层
            横向重复：不涉及
            纵向重复：元素可以重复，但每次集合不同，所以避免了这个问题
        解决：
            搜索时：回溯依次对一个集合进行搜索，按顺序+1即可
            
    4.组合总和（⼆）：39. 组合总和
        问题：
            给定⼀个⽆重复元素的数组 candidates 和⼀个⽬标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
            candidates 中的数字可以⽆限制重复被选取。
        特点：
            组合问题
            组合没有数量要求
            元素可⽆限重复选取
            上下两层搜索有关联，不能再搜索之前的位置，因此设置startindex
        分析：
            集合：candidates，每次搜索相同
            要求：和为target，结果集元素个数不限
        搜索树：
            横向：candidates的长度
            纵向：根据当前和调整，长度是动态的
            异构重复：不能异构
            元素重复：可以重复
        解决：
            递归终⽌条件:
                sum⼤于target:不符合，直接return
                sum等于target:符合，加入
            单次逻辑：
                单层for循环依然是从startIndex开始，搜索candidates集合。
                重复选取：backtrack(i)（元素可以重复：下次搜索时还是i）
        优化；
            剪枝:
                对总集合排序之后，如果下⼀层的sum（就是本层的 sum + candidates[i]）已经⼤于target，就可以结束本轮for循环的遍历。
    5.组合总和（三）    40.组合总和II   数层去重(集合有重复元素)
        问题：
            给定⼀个数组 candidates(有重复元素) 和⼀个⽬标数 target ，找出 candidates 中所有可以使数字和为target 的组合。
            candidates 中的每个数字在每个组合中只能使⽤⼀次
        特点：
            组合问题
            集合里元素有重复，但是结果不能异构
            元素不能重复：“使⽤过的元素不能重复选取”
            组合没有数量要求
        分析：
            集合：candidates
            要求：和为target，结果集元素个数不限
        搜索树：
            横向：candidates长度
            纵向：根据当前和调整搜索树深度，长度是动态的(组合没有数量要求)
            异构重复：不能重复
            元素重复：不能重复
        解决：
            递归终⽌条件：sum > target 和 sum == target
            单层搜索的逻辑：
                for()搜索遍历集合
                对同一树层使用过的元素进行跳过
                if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                    continue;
                }
                如果使用过，则对应usde[i]赋1, used[i] = true;

    {
        难点：集合（数组candidates）有重复元素，但还不能有重复的组合。
        去重：使⽤过的元素不能重复选取
        组合问题可以抽象为树形结构，那么“使⽤过”在这个树形结构上是有两个维度的：
            ⼀个维度是同⼀树枝上使⽤过，(元素能不能重复，由于是一个集合里的元素，不用去重)  相等元素不是相同(同一个)元素
            ⼀个维度是同⼀树层上使⽤过。
            没有理解这两个层⾯上的“使⽤过” 是造成⼤家没有彻底理解去重的根本原因。
            回看⼀下题⽬，元素在同⼀个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。
        我们要去重的是同⼀树层上的“使⽤过”，同⼀树枝上的都是⼀个组合⾥的元素，不⽤去重。
        
        为了理解去重我们来举⼀个例⼦，candidates = [1, 1, 2], target = 3，（⽅便起见candidates已经排序了）
        强调⼀下，树层去重的话，需要对数组排序！
        解决方法：
            多加了bool型数组used，⽤来记录同⼀树枝上的元素是否使⽤过，初始都为0，如果使用，则赋1。
            要去重的是“同⼀树层上的使⽤过”，如果判断同⼀树层上元素（相同的元素）是否使⽤过了呢。
            如果candidates[i] == candidates[i - 1] 并且 used[i - 1] == false，
            就说明：前⼀个树枝，使⽤了candidates[i - 1]，也就是说同⼀树层使⽤过candidates[i - 1]。
        数层去重：[1,1,2],假如搜索过第一个1，则不用再对第二个1搜索，否则会重复。
    }
    6.分割回文串 131.分割回文串 切割问题
    问题：
        给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
        返回 s 所有可能的分割方案。
        示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]
    分析：
        集合：字符串s
        要求：切割子串，子串是回文串
    搜索树：
        横向：集合s
        纵向：s切割完为止，或者判断切割后是不是回文串
        异构重复：可以
        元素重复：可以
    解决：
        无需解决，很简单，主要是做判断。
    优化：
        剪枝：
    7.复原IP地址  93.复原IP地址
    题目：
        给定一个只包含数字的字符串s，复原它并返回所有可能的 IP 地址格式。
        有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
    分析：
        集合:s
        要求：切割问题，判断是否合法
        
            


*/