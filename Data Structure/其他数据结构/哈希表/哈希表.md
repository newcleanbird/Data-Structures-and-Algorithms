# 哈希表与哈希函数

哈希表：(Hash table)也称散列表,根据key值来直接访问数据，查找速度快

## 哈希表

### 哈希表定义

**散列表**（Hash table，也叫**哈希表**），是根据键（Key）而直接访问在内存存储位置的数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。
这个映射函数称做**散列函数**，存放记录的数组称做散列表。

注意：

- 哈希表是一个数据结构
- 散列表是数组结构

特点：

- O(1) 的时间复杂度下进行数据查找

## 哈希函数

### 哈希函数定义

**哈希函数**也叫**映射函数、散列函数**，数据查找的数据结构就叫做哈希表，对键的计算的方法叫做哈希函数。

- 哈希函数是一种提取数据特征的算法，针对不通的数据形式有不同的哈希算法，所以哈希函数并不通用，针对不同场景有很多不同的哈希算法，
- 比如我们常见的MD5就是一种获取文件信息摘要的哈希算法。
  - 把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。
  - 通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

### 哈希函数输入输出

- 输入：关键值key
- 输出：位置(数组)

### 哈希函数的特点

- 输入域无限大
- 输出域有界
- 输入参数是固定的情况下，返回值也是固定的
- 输入参数不同时，返回值可能是相同的(哈希冲突)
- 当输入参数很多时，输出的每个数的概率大致是均匀的

### 哈希函数的推广

当若干输入经过哈希函数，得到均匀分布的hash_code，给这些hash_code取模m，则取模后的hash_code在0~m-1上也是均匀分布的。

### 设计哈希函数

1. 直接定址法：取关键字或关键字的某个线性函数值为哈希地址。
2. 数字分析法：假设关键字是以r为基的数（如：以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
3. 平方取中法：取关键字平方后的中间几位为哈希地址。
4. 斐波那契（Fibonacci）散列法
5. 折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址，这方法称为折叠法。
6. 除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。即H(key)=key MOD p,(p<=m)，这是一种最简单，也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（MOD），也可在折叠、平方取中等运算之后取模。
7. 随机数法：选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key)，其中random为随机函数。通常，当关键字长度不等时采用此法构造哈希函数较切当。

### 哈希函数解决问题

- 快速判断一个元素是否出现集合里。
- 枚举的话时间复杂度是O(n)，但如果使用哈希表的话，只需要O(1)就可以做到。

### 存储方式

- 底层实现：数组。
  - 下表从0开始，连续的，直接通过下标访问
- 键值对：有一个key和一个value对应着，比如101011是键值key，对应value张三，学生的学号和姓名就是一个键值对
  - Entry：在java jdk里把键值对叫做Entry
  - 在散列表中存储的是键值对

## 哈希碰撞

- 定义：哈希冲突是指多个不同的键散列到了同一个数组下标位置上

- 解决办法：拉链法、开放地址法
  - 拉链法：
    - 链地址法俗称拉链法，就是在冲突的下标元素处维护一个链表，所有冲突的元素都依次放到这个链表上去：
  - 开放地址法：
    - 线性探测法：下标被占用之后，以步长为1依次向后寻找。
    - 二次探测法：下标被占用之后，步长为2的倍数，依次向后寻找。
    - 伪随机探测法：下标被占用后，随机出一个数字，然后使用这个数字作为下标进行寻找，这种方法全靠天意了。

## C++ STL 哈希表的实现

- map

- hash_map
- unordered_map

### map

    C++ STL库的map，map提供一个很常用的功能，那就是提供key-value的存储和查找功能，但是它内部实现机制是基于红黑树的。
    map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。
    Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的。
    比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。
    map提供了一对一的映射关系，但是显然它的查找时间复杂度O(logN)的，对于数量庞大的数据来说，查找显然还是太慢了。
    上面介绍了哈希表的时间复杂度是O（1）,而hash_map就是基于哈希表来实现的。

### hash_map

    前面在哈希表的介绍中，我们了解到，“直接定址”与“解决冲突”是哈希表的两大特点。
    hash_map，首先分配一大片内存，形成许多桶。是利用hash函数，对key进行映射到不同区域（桶）进行保存。

    hash_map 插入过程是：
    (1)得到key
    (2)通过hash函数得到hash值
    (3)得到桶号(一般都为hash值对桶数求模)
    (4)存放key和value在桶内。
    hash_map 取值过程是:
    (1)得到key
    (2)通过hash函数得到hash值
    (3)得到桶号(一般都为hash值对桶数求模)
    (4)比较桶的内部元素是否与key相等，若都不相等，则没有找到。
    (5)取出相等的记录的value。
    
    hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决。
    这里可以看出，如果每个桶内部只有一个元素，那么查找的时候只有一次比较。
    当许多桶内没有值时，许多查询就会更快了(指查不到的时候).

    由此可见，要实现哈希表, 和用户相关的是：hash函数和比较函数。这两个参数刚好是我们在使用hash_map时需要指定的参数。

    但是我们在初始化hash_map时，好像没有去制定hash函数和比较函数，原因是我们使用了缺省函数，自动帮我们设置了hash函数和比较函数

### nordered_map

#### 引入原因

    实际上，最初的 C++ 标准库中没有类似 hash_map 的实现，但不同实现者自己提供了非标准的 hash_map。
    因为这些实现不是遵循标准编写的，所以它们在功能和性能保证方面都有细微差别。
    从 C++ 11 开始，hash_map 实现已被添加到标准库中。但为了防止与已开发的代码存在冲突，决定使用替代名称 unordered_map。
    这个名字其实更具描述性，因为它暗示了该类元素的无序性。

#### unordered_map的用法

    参考：<https://blog.csdn.net/lizhengze1117/article/details/96728468>

## 总结

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组:哈希值比较小，范围比较小(可控，即对比数量比较小，26字母)
- set(集合)：数值很大
- map(映射)：要用到 key-value

这里数组就没啥可说的了，我们来看一下set。

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合:              | 底层实现 | 是否有序  | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率 |
| std::set           | 红黑树   | 有序      | 否             | 否           | O(log n)  | O(log n) |
| std::multiset      | 红黑树   | 有序      | 是             | 否           | O(logn)   | O(logn)  |
| std::unordered_set | 哈希表   | 无序      | 否             | 否           | O(1)      | O(1)     |

std::unordered_set底层实现为哈希表
std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复| 能否更改数值 | 查询效率 | 增删效率 |
| std::map           | 红黑树   | key有序 | key不可重复     | key不可修改  | O(logn) | O(logn)  |
| std::multimap      | 红黑树   | key有序 | key可重复       | key不可修改  | O(log n)| O(log n) |
| std::unordered_map | 哈希表   | key无序 | key不可重复     | key不可修改  | O(1)    | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。
同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

使用：
    当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，
    如果需要集合是有序的，那么就用set，
    如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。
其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。
虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。
这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？

实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。

总结一下，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。
但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。
如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

适合题目：
    记录字符出现频率：
    比较字母频率：
    “重复”“次数多少”：
