# KMP算法

Knuth-Morris-Pratt算法（KMP算法）是一种改进的字符串匹配算法，由Donald Knuth、James H. Morris和Vaughan Pratt三位计算机科学家共同提出。KMP算法的关键在于利用已经获得的匹配信息，通过构建一个“部分匹配表”（也称为“失配表”或“前缀函数”），在不匹配发生时避免重新检查已经匹配过的字符，从而减少不必要的字符比较，达到较高的匹配效率。

## 算法核心思想

1. 部分匹配表（Prefix Function）：KMP算法首先对模式串构建一个部分匹配表。这个表记录了模式串中每个位置之前的子串最长的、同时又是模式串前缀的子串的长度。通过这个表，算法可以在遇到不匹配时知道已经比较了多少字符，并且可以利用这些信息跳过一些不必要的字符比较。

2. 滑动窗口：KMP算法使用一个“滑动窗口”的概念来比较模式串与目标串。当模式串中的字符与目标串中的字符不匹配时，不是像暴力匹配那样简单地将模式串向右滑动一位，而是根据部分匹配表，直接将模式串滑动到一个可能正确对齐的位置，继续比较。

## 步骤详解

1. 构建部分匹配表：
   - 初始化表的第一个值为0，表示空串没有前缀。
   - 从第二个字符开始，依次计算每个字符对应的最长前缀长度。若当前字符与前缀末尾的字符相同，则当前字符的前缀长度为前一字符的前缀长度加一；否则，从前缀表中找到一个合适的更短的前缀使得当前字符与该前缀末尾字符匹配，其长度即为当前字符的前缀长度。

2. 匹配过程：
   - 将模式串的第一个字符与目标串的第一个字符开始比较，如果匹配则继续比较下一个字符。
   - 当模式串中的字符与目标串中的字符不匹配时，利用部分匹配表确定模式串应该跳到的位置，而不是简单地向后移动一个字符。
   - 继续上述过程，直到模式串的最后一个字符与目标串中的字符匹配，此时匹配成功；或者模式串的最后一个字符已经比较过，但未找到匹配，此时匹配失败。

## 优点

- 效率高：KMP算法的时间复杂度为O(n+m)，其中n为目标串长度，m为模式串长度，相比暴力匹配算法在最坏情况下有显著提升。
- 无需回溯：利用部分匹配表避免了不必要的回溯，提高了匹配效率。

## 缺点

- 预处理时间：虽然匹配过程效率高，但构建部分匹配表需要O(m)的时间，对于非常长的模式串，预处理时间也是一个考虑因素。

## C++实现

[KMP算法 C++实现](./KMP.cpp)
