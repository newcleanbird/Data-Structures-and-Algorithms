# Sunday算法

Sunday算法，又称为Sunday搜索算法，是由Daniel M. Sunday于1990年提出的一种字符串搜索算法，主要用于在一个较长的文本串（haystack）中查找一个较短的模式串（needle）出现的位置。它的设计目的是为了在许多实际应用场景中提供高效的字符串匹配，尽管在最坏情况下的时间复杂度与其他高级算法（如KMP、Boyer-Moore）相同，但在某些数据分布下，Sunday算法能够表现出更好的平均性能。

## 核心思想

Sunday算法的核心思想是在模式串与文本串匹配失败时，根据文本串中参与匹配的最后一个字符在模式串中的下一个出现位置来决定模式串应该向右滑动的距离。具体来说，算法执行以下步骤：

1. 初始化：将模式串与文本串的起始位置对齐。
2. 比较：从模式串的第一个字符开始，与文本串对应位置的字符逐一比较。
3. 匹配成功：如果所有字符都匹配成功，则找到了一个匹配位置。
4. 匹配失败：如果在某个位置字符不匹配，算法不会简单地将模式串向右滑动一位，而是根据以下规则决定滑动距离：
   - 查找文本串中当前不匹配字符的下一个字符在模式串中的位置。
   - 如果该字符不存在于模式串中，模式串直接跳过整个自身长度加1的位置。
   - 如果该字符存在于模式串中，则模式串向右滑动到该字符在模式串中出现位置之后的那个位置，如果该字符在模式串末尾，则相当于模式串向右滑动整个模式串长度的位置。
5. 重复：重复步骤2到4，直到找到匹配或者模式串滑出文本串的边界。

## 优势

- 简单性：相较于KMP和Boyer-Moore算法，Sunday算法的实现更为直观和简单。
- 效率：在某些文本和模式串的分布下，尤其是当文本串中有许多重复字符时，Sunday算法能够通过较大的跳跃减少不必要的比较次数，提高效率。
- 灵活性：算法允许在匹配失败时灵活地选择跳过尽可能多的字符，这在某些特定数据集上可能比固定规则的算法（如Boyer-Moore的坏字符规则）表现更好。

## 缺点

- 最坏情况性能：尽管在平均情况下表现良好，Sunday算法在最坏情况下的时间复杂度仍然是O(n*m)，其中n是文本串的长度，m是模式串的长度。
- 依赖文本特性：算法的效率高度依赖于文本串的特性，如果文本串中字符分布均匀，频繁的字符跳过将较少，效率降低。

## 实现

实现Sunday算法时，通常需要维护一个辅助数据结构来快速查找文本串中不匹配字符在模式串中的下一个位置，这可以通过构建一个简单的查找表来实现。

[sundaySearch](./sundaySearch.cpp)
