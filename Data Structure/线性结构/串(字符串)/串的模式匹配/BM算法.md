# BM 算法

Boyer-Moore算法是一种高效的字符串搜索算法，由Robert S. Boyer和J Strother Moore于1977年提出。它通过利用两个关键规则来加速匹配过程：坏字符规则（Bad Character Rule）和好后缀规则（Good Suffix Rule）。这两种规则允许算法在检测到不匹配时快速跳跃，从而减少了不必要的字符比较，尤其是在文本串很长或者模式串中包含重复序列的情况下，效率尤为显著。

## 坏字符规则（Bad Character Rule）

- 目的：当模式串中的字符与文本串中的字符不匹配时，算法会根据不匹配字符在模式串中的位置和它在模式串中最右端的相同字符的位置来决定跳过多少字符。
- 实现：预先构建一个坏字符表，表中记录了模式串中每个字符最后一次出现的位置。如果模式串中的某字符与文本串中的相应字符不匹配，算法会将模式串向右滑动，使不匹配的字符与它在模式串中最后一次出现的位置对齐。如果该字符在模式串中只出现一次或未出现，模式串将直接滑动到该字符之后。

## 好后缀规则（Good Suffix Rule）

- 目的：当模式串的后缀与文本串的一个子串相匹配，但整个模式串仍不匹配时，好后缀规则帮助确定模式串应向右滑动多少位。
- 实现：构建一个好后缀表，记录模式串中每个后缀的最长相同前缀以及相应的偏移量。当模式串的末尾与文本串不匹配时，算法会查找模式串中是否存在一个与当前不匹配之后的文本子串相匹配的好后缀。如果有，算法将模式串滑动到该好后缀对齐的位置。

## 算法流程

1. 预处理阶段：构建坏字符表和好后缀表，这是算法高效的关键。
2. 匹配阶段：从文本串的最右侧开始，比较模式串的最右侧字符与文本串的字符。如果不匹配，根据坏字符规则和好后缀规则决定模式串的滑动距离。如果匹配，向前比较下一个字符，直到模式串完全匹配或出现不匹配。
3. 终止条件：模式串完全匹配文本串的某个子串，或者模式串滑动到文本串的尽头。

## 时间复杂度

在平均和大多数情况下，Boyer-Moore算法的时间复杂度为O(n/m)，其中n是文本串长度，m是模式串长度，这使得它在模式串较长或文本串非常大的情况下特别有效。最坏情况下，时间复杂度仍然是线性的，但通常优于暴力匹配算法的O(mn)。

## 适用场景

Boyer-Moore算法因其高效性，广泛应用于大规模文本搜索、文件系统搜索、源代码编辑器、编译器的词法分析、生物信息学中的DNA序列匹配等领域。

## 实现

[BM算法 C++实现](./Boyer-Moore.cpp)
